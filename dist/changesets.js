// Generated by CoffeeScript 1.7.1
(function() {
  var compare, compareArray, compareObject, comparePrimitives, convertArrayToObj, exports, getTypeOfObj, op, _;

  _ = require('underscore');

  op = {
    DELETED: 'deleted',
    ADDED: 'added',
    MODIFIED: 'modified'
  };

  getTypeOfObj = function(obj) {
    if (typeof obj === 'undefined') {
      return 'undefined';
    }
    if (obj === null) {
      return null;
    }
    return Object.prototype.toString.call(obj).match(/^\[object\s(.*)\]$/)[1];
  };

  compare = function(oldObj, newObj, path, embededObjKeys) {
    var changes, typeOfNewObj, typeOfOldObj;
    changes = [];
    typeOfOldObj = getTypeOfObj(oldObj);
    typeOfNewObj = getTypeOfObj(newObj);
    if (typeOfOldObj !== typeOfNewObj) {
      changes.push({
        type: op.DELETED,
        key: path,
        value: oldObj
      });
      changes.push({
        type: op.ADDED,
        key: path,
        value: newObj
      });
    }
    switch (typeOfOldObj) {
      case 'Object':
        changes = changes.concat(compareObject(oldObj, newObj, path, embededObjKeys));
        break;
      case 'Array':
        changes = changes.concat(compareArray(oldObj, newObj, path, embededObjKeys));
        break;
      case 'Function':
        break;
      default:
        changes = changes.concat(comparePrimitives(oldObj, newObj, path));
    }
    return changes;
  };

  compareObject = function(oldObj, newObj, path, embededObjKeys) {
    var addedKeys, changes, deletedKeys, intersectionKeys, k, newObjKeys, newPath, oldObjKeys, _i, _j, _k, _len, _len1, _len2;
    changes = [];
    oldObjKeys = Object.keys(oldObj);
    newObjKeys = Object.keys(newObj);
    addedKeys = _.difference(newObjKeys, oldObjKeys);
    for (_i = 0, _len = addedKeys.length; _i < _len; _i++) {
      k = addedKeys[_i];
      newPath = path.concat([k]);
      changes.push({
        type: op.ADDED,
        key: newPath,
        value: newObj[k]
      });
    }
    deletedKeys = _.difference(oldObjKeys, newObjKeys);
    for (_j = 0, _len1 = deletedKeys.length; _j < _len1; _j++) {
      k = deletedKeys[_j];
      newPath = path.concat([k]);
      changes.push({
        type: op.DELETED,
        key: newPath,
        value: oldObj[k]
      });
    }
    intersectionKeys = _.intersection(oldObjKeys, newObjKeys);
    for (_k = 0, _len2 = intersectionKeys.length; _k < _len2; _k++) {
      k = intersectionKeys[_k];
      newPath = path.concat([k]);
      changes = changes.concat(compare(oldObj[k], newObj[k], newPath, embededObjKeys));
    }
    return changes;
  };

  compareArray = function(oldObj, newObj, path, embededObjKeys) {
    var changes, indexedNewObj, indexedOldObj, uniqKey;
    uniqKey = embededObjKeys != null ? embededObjKeys[path.join('.')] : void 0;
    indexedOldObj = convertArrayToObj(oldObj, uniqKey);
    indexedNewObj = convertArrayToObj(newObj, uniqKey);
    return changes = compareObject(indexedOldObj, indexedNewObj, path, embededObjKeys);
  };

  convertArrayToObj = function(arr, uniqKey) {
    var index, key, obj, value, _i, _len;
    obj = {};
    if (uniqKey) {
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        value = arr[_i];
        key = value[uniqKey];
        obj["$" + key] = value;
      }
    } else {
      for (index in arr) {
        value = arr[index];
        obj["$" + index] = value;
      }
    }
    return obj;
  };

  comparePrimitives = function(oldObj, newObj, path) {
    var changes;
    changes = [];
    if (oldObj !== newObj) {
      changes.push({
        type: op.MODIFIED,
        key: path,
        value: newObj,
        oldValue: oldObj
      });
    }
    return changes;
  };

  module.exports = exports = {
    diff: function(oldObj, newObj, embededObjKeys) {
      return compare(oldObj, newObj, [], embededObjKeys);
    },
    apply: function() {},
    revert: function() {}
  };

}).call(this);
