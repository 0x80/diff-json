// Generated by CoffeeScript 1.7.1
(function() {
  var addKeyValue, applyChange, compare, compareArray, compareObject, comparePrimitives, convertArrayToObj, getNextPtr, getTypeOfObj, indexOfItemInArray, isEmbeddedKey, modifyKeyValue, parseEmbeddedKeyValue, removeKey, revertChange, _;

  _ = require('underscore');

  exports.op = {
    DELETED: '-',
    ADDED: '+',
    MODIFIED: '+-'
  };

  getTypeOfObj = function(obj) {
    if (typeof obj === 'undefined') {
      return 'undefined';
    }
    if (obj === null) {
      return null;
    }
    return Object.prototype.toString.call(obj).match(/^\[object\s(.*)\]$/)[1];
  };

  compare = function(oldObj, newObj, path, embededObjKeys) {
    var changes, typeOfNewObj, typeOfOldObj;
    changes = [];
    typeOfOldObj = getTypeOfObj(oldObj);
    typeOfNewObj = getTypeOfObj(newObj);
    if (typeOfOldObj !== typeOfNewObj) {
      changes.push({
        type: exports.op.DELETED,
        key: path,
        value: oldObj
      });
      changes.push({
        type: exports.op.ADDED,
        key: path,
        value: newObj
      });
    }
    switch (typeOfOldObj) {
      case 'Object':
        changes = changes.concat(compareObject(oldObj, newObj, path, embededObjKeys));
        break;
      case 'Array':
        changes = changes.concat(compareArray(oldObj, newObj, path, embededObjKeys));
        break;
      case 'Function':
        break;
      default:
        changes = changes.concat(comparePrimitives(oldObj, newObj, path));
    }
    return changes;
  };

  compareObject = function(oldObj, newObj, path, embededObjKeys) {
    var addedKeys, changes, deletedKeys, intersectionKeys, k, newObjKeys, newPath, oldObjKeys, _i, _j, _k, _len, _len1, _len2;
    changes = [];
    oldObjKeys = Object.keys(oldObj);
    newObjKeys = Object.keys(newObj);
    intersectionKeys = _.intersection(oldObjKeys, newObjKeys);
    for (_i = 0, _len = intersectionKeys.length; _i < _len; _i++) {
      k = intersectionKeys[_i];
      newPath = path.concat([k]);
      changes = changes.concat(compare(oldObj[k], newObj[k], newPath, embededObjKeys));
    }
    addedKeys = _.difference(newObjKeys, oldObjKeys);
    for (_j = 0, _len1 = addedKeys.length; _j < _len1; _j++) {
      k = addedKeys[_j];
      newPath = path.concat([k]);
      changes.push({
        type: exports.op.ADDED,
        key: newPath,
        value: newObj[k]
      });
    }
    deletedKeys = _.difference(oldObjKeys, newObjKeys);
    for (_k = 0, _len2 = deletedKeys.length; _k < _len2; _k++) {
      k = deletedKeys[_k];
      newPath = path.concat([k]);
      changes.push({
        type: exports.op.DELETED,
        key: newPath,
        value: oldObj[k]
      });
    }
    return changes;
  };

  compareArray = function(oldObj, newObj, path, embededObjKeys) {
    var changes, indexedNewObj, indexedOldObj, uniqKey;
    uniqKey = embededObjKeys != null ? embededObjKeys[path.join('.')] : void 0;
    indexedOldObj = convertArrayToObj(oldObj, uniqKey);
    indexedNewObj = convertArrayToObj(newObj, uniqKey);
    return changes = compareObject(indexedOldObj, indexedNewObj, path, embededObjKeys);
  };

  convertArrayToObj = function(arr, uniqKey) {
    var index, key, obj, value, _i, _len;
    obj = {};
    if (uniqKey) {
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        value = arr[_i];
        key = value[uniqKey];
        obj["$" + uniqKey + "=" + key] = value;
      }
    } else {
      for (index in arr) {
        value = arr[index];
        obj[index] = value;
      }
    }
    return obj;
  };

  comparePrimitives = function(oldObj, newObj, path) {
    var changes;
    changes = [];
    if (oldObj !== newObj) {
      changes.push({
        type: exports.op.MODIFIED,
        key: path,
        value: newObj,
        oldValue: oldObj
      });
    }
    return changes;
  };

  applyChange = function(obj, change) {
    var index, key, keys, ptr;
    keys = change.key;
    ptr = obj;
    for (index in keys) {
      key = keys[index];
      if (+index === (keys.length - 1)) {
        switch (change.type) {
          case exports.op.ADDED:
            addKeyValue(ptr, key, change.value);
            break;
          case exports.op.MODIFIED:
            modifyKeyValue(ptr, key, change.value);
            break;
          case exports.op.DELETED:
            removeKey(ptr, key);
            break;
          default:
            throw new Error("Unrecongnised change type " + change.type);
        }
      } else {
        ptr = getNextPtr(ptr, key);
      }
    }
    return obj;
  };

  isEmbeddedKey = function(key) {
    return /\$.*=/gi.test(key);
  };

  removeKey = function(obj, key) {
    var index, uniqKey, value, _ref;
    if (Array.isArray(obj)) {
      if (isEmbeddedKey(key)) {
        _ref = parseEmbeddedKeyValue(key), uniqKey = _ref.uniqKey, value = _ref.value;
        index = indexOfItemInArray(obj, uniqKey, value);
      }
      return obj.splice(key, 1);
    } else {
      return delete obj[key];
    }
  };

  indexOfItemInArray = function(arr, key, value) {
    var index, item;
    for (index in arr) {
      item = arr[index];
      if (item[key] === value) {
        return index;
      }
    }
    return -1;
  };

  modifyKeyValue = function(obj, key, value) {
    return obj[key] = value;
  };

  addKeyValue = function(obj, key, value) {
    if (Array.isArray(obj)) {
      return obj.push(value);
    } else {
      return obj[key] = value;
    }
  };

  getNextPtr = function(obj, key) {
    var uniqKey, value, _ref;
    if (Array.isArray(obj) && isEmbeddedKey(key)) {
      _ref = parseEmbeddedKeyValue(key), uniqKey = _ref.uniqKey, value = _ref.value;
      return _.find(obj, function(item) {
        return item[uniqKey] === value;
      });
    }
    return obj[key];
  };

  parseEmbeddedKeyValue = function(key) {
    var uniqKey, value;
    uniqKey = key.substring(1, key.indexOf('='));
    value = key.substring(key.indexOf('=') + 1);
    return {
      uniqKey: uniqKey,
      value: value
    };
  };

  revertChange = function(obj, change) {
    var index, key, keys, ptr;
    keys = change.key;
    ptr = obj;
    for (index in keys) {
      key = keys[index];
      if (+index === (keys.length - 1)) {
        switch (change.type) {
          case exports.op.ADDED:
            removeKey(ptr, key);
            break;
          case exports.op.MODIFIED:
            modifyKeyValue(ptr, key, change.oldValue);
            break;
          case exports.op.DELETED:
            addKeyValue(ptr, key, change.value);
            break;
          default:
            throw new Error("Unrecongnised change type " + change.type);
        }
      } else {
        ptr = getNextPtr(ptr, key);
      }
    }
    return obj;
  };

  exports.diff = function(oldObj, newObj, embededObjKeys) {
    return compare(oldObj, newObj, [], embededObjKeys);
  };

  exports.applyChange = function(obj, changeset) {
    var change, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = changeset.length; _i < _len; _i++) {
      change = changeset[_i];
      _results.push(applyChange(obj, change));
    }
    return _results;
  };

  exports.revertChange = function(obj, changeset) {
    var change, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = changeset.length; _i < _len; _i++) {
      change = changeset[_i];
      _results.push(revertChange(obj, change));
    }
    return _results;
  };

}).call(this);
